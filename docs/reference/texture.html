<script type="text/javascript">

    MAKE_PARAGRAPH( `Site under construction...` + LX.makeIcon( "Construction", { svgClass: "xxl"  } ).innerHTML );

    MAKE_HEADER( "Texture", "h1", "texture" );
    MAKE_PARAGRAPH( `The Texture class handles GPU texture creation, loading, updating, and mipmap generation, supporting standard and HDR formats. It stores metadata like dimensions, format, usage, and wrap modes, and can optionally retain CPU-side pixel data. Textures can be accessed via views, and utility functions allow format conversion and parameter setup.` );
    MAKE_LINE_BREAK();

    MAKE_CLASS_CONSTRUCTOR( "Texture", [] );

    MAKE_LINE_BREAK();

    {
        const area = new LX.Area( { skipAppend: true, height: "auto", className: "mb-6" } );
        const panel = area.addPanel();
        content.appendChild( area.root );

        panel.addTable( null, {
            head: [ "Return type", "Method", "Parameters" ],
            body: [
                ["void", "load", "const std::string&amp; texture_path, bool is_srgb, bool upload_to_vram = true, bool store_texture_data = false"],
                ["void", "load_hdr", "const std::string&amp; texture_path, bool store_texture_data = false"],
                ["void", "create", "WGPUTextureDimension dimension, WGPUTextureFormat format, WGPUExtent3D size, WGPUTextureUsage usage, uint32_t mipmaps, uint8_t sample_count, const void* data"],
                ["void", "update", "void* data, uint32_t mip_level, WGPUOrigin3D origin"],
                ["void", "generate_mipmaps", "const void* data"],
                ["static bool", "convert_to_rgba8unorm", "uint32_t width, uint32_t height, WGPUTextureFormat src_format, void* src, uint8_t* dst"],
                ["WGPUTexture", "get_texture", "—"],
                ["WGPUTextureView", "get_view", "WGPUTextureViewDimension view_dimension = WGPUTextureViewDimension_2D, uint32_t base_mip_level = 0, uint32_t mip_level_count = 1, uint32_t base_array_layer = 0, uint32_t array_layer_count = 1"],
                ["uint32_t", "get_mipmap_count", "—"],
                ["WGPUTextureDimension", "get_dimension", "—"],
                ["void", "set_wrap_u", "WGPUAddressMode wrap_u"],
                ["void", "set_wrap_v", "WGPUAddressMode wrap_v"],
                ["WGPUAddressMode", "get_wrap_u", "—"],
                ["WGPUAddressMode", "get_wrap_v", "—"],
                ["uint32_t", "get_width", "—"],
                ["uint32_t", "get_height", "—"],
                ["uint32_t", "get_array_layers", "—"],
                ["sTextureData&amp;", "get_texture_data", "—"],
                ["const sTextureData&amp;", "get_texture_data", "—"],
                ["WGPUTextureFormat", "get_format", "—"],
                ["WGPUExtent3D", "get_size", "—"],
                ["bool", "is_srgb", "—"],
                ["void", "load_from_data", "const std::string&amp; name, WGPUTextureDimension dimension, int width, int height, int array_layers, void* data, bool create_mipmaps = true, WGPUTextureFormat p_format = WGPUTextureFormat_RGBA8Unorm"],
                ["void", "load_from_hdre", "HDRE* hdre"],
                ["void", "set_texture_parameters", "const std::string&amp; name, WGPUTextureDimension dimension, int width, int height, int array_layers, bool create_mipmaps = true, WGPUTextureFormat p_format = WGPUTextureFormat_RGBA8Unorm"],
                ["void", "load_from_data", "void* data"]
            ].map( v => {
                return [ INLINE_CODE( v[ 0 ], "table desc" ), INLINE_CODE( v[ 1 ], "table" ), v[ 2 ] != "—" ? INLINE_CODE( v[ 2 ], "desc text-sm" ) : v[ 2 ] ];
            } )
        }, { filter: "Method" });
    }

    MAKE_LINE_BREAK();
    MAKE_LINE_BREAK();

</script>