<script type="text/javascript">

    MAKE_PARAGRAPH( `Site under construction...` + LX.makeIcon( "Construction", { svgClass: "xxl"  } ).innerHTML );

    MAKE_HEADER( "MeshInstance3D", "h1", "mesh-instance-3D" );
    MAKE_PARAGRAPH( `A 3D node that encapsulates a MeshInstance, extending Node3D with rendering, material management, and visibility controls. It supports adding surfaces, material overrides per surface, AABB updates, frustum culling, and shadow reception toggling. It is optionally skinned and is responsible for rendering itself and its associated mesh.` );
    MAKE_LINE_BREAK();

    MAKE_CLASS_CONSTRUCTOR( "MeshInstance3D", [] );

    MAKE_LINE_BREAK();

    {
        const area = new LX.Area( { skipAppend: true, height: "auto", className: "mb-6" } );
        const panel = area.addPanel();
        content.appendChild( area.root );

        panel.addTable( null, {
            head: [ "Type", "Member", "Default" ],
            body: [
                ["bool", "is_skinned", "false"],
            ].map( v => {
                return [ INLINE_CODE( v[ 0 ], "table desc" ), INLINE_CODE( v[ 1 ], "table" ), v[ 2 ] != "—" ? INLINE_CODE( v[ 2 ], "table desc" ) : v[ 2 ] ];
            } )
        }, {});
        panel.addBlank( null, "24px" );
        panel.addTable( null, {
            head: [ "Return type", "Method", "Parameters" ],
            body: [
                ["void", "render", "—"],
                ["void", "update", "float delta_time"],
                ["void", "add_surface", "Surface* surface"],
                ["void", "update_aabb", "—"],
                ["void", "set_aabb", "const AABB&amp; new_aabb"],
                ["void", "set_surface_material_override", "Surface* surface <br> Material* material"],
                ["void", "set_frustum_culling_enabled", "bool enabled"],
                ["void", "set_receive_shadows", "bool new_receive_shadows"],
                ["MeshInstance*", "get_mesh_instance", "—"],
                ["bool", "get_frustum_culling_enabled", "—"],
                ["Material*", "get_surface_material", "int surface_idx"],
                ["Material*", "get_surface_material_override", "Surface* surface"],
                ["const std::vector&lt;Surface*&gt;&amp;", "get_surfaces", "—"],
                ["Surface*", "get_surface", "int surface_idx"],
                ["uint32_t", "get_surface_count", "—"],
                ["void", "render_gui", "—"]
            ].map( v => {
                return [ INLINE_CODE( v[ 0 ], "table desc" ), INLINE_CODE( v[ 1 ], "table" ), v[ 2 ] != "—" ? INLINE_CODE( v[ 2 ], "desc text-sm" ) : v[ 2 ] ];
            } )
        }, { filter: "Method" });
    }

    MAKE_LINE_BREAK();
    MAKE_LINE_BREAK();

</script>